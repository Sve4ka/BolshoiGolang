# homework 1 
## 1. Сделайте тип со следующими методами:
- Set(key,value string), сохраняющий значение по ключу. В value в формате строки может прийти целое число либо строка ("mystring" или "22").
- Get(key string) *string, возвращающий сохраненный по ключу key value. Если для key не сохранено никакого значения, требуется вернуть nil.
- GetKind(key string)string. Этот метод должен вернуть тип значения по ключу key. Для строковых значений требуется возвращать "S", для числовых "D".

Добавьте в main код, показывающий что ваш тип работает и выполняет поставленную задачу.
Выложите ваш код в репозиторий на github. На этой неделе соберем с вас ссылки на ваши репозитории.

Nice to have:
Добавьте в ваше приложение zap.Logger, пишите информацию в логгер там где это может быть полезно (хотя бы одно место).

# HomeWork 2
1. Добавьте тест с таблицей тесткейсов, который бы проверял базовый сценарий Set(key, value), Get(key) == value
2. Добавьте тест, который бы проверял, что Set(key, value) правильно определяет тип у value. Напомню, что пока мы поддерживаем два типа: "D" - int и "S" - string
3. Создайте бенчмарки ваших функций (сохраните где-то в вашем проекте, например, в папке benchmark_results в корне проекта, результаты текущих бенчмарков)
    1. Get(key) (не забудьте сбросить таймер, перед тем, как бенчмаркать Get)
    2. Set(key, value)
    3. Set(key, value), Get(key, value)
4. (Optional) Прочитать [Go Uber Style Guide](https://github.com/uber-go/guide) и материалы из 

# homework 3

## 1. Добавить новые операции
Добавить отдельные методы для работы с массивами (массивы хранить в другой мапе, не там же где базовые типы и предыдущих занятий). Далее идет текстовое описание каждой новой операции, как если бы работы с приложением происходила через интерактивную командную строку (например, как в оболочками SQL). Вам нужно написать только функции для выполнения этих операций, необходимую сигнатуру определите сами.

### LPUSH key element [element ...]
Вставляет элементы слева в список по ключу key. Если элементов несколько, они вставляются так, как будто для каждого из них по порядку была бы вызвана эта команда. Если значения по ключу не существовало, список создается.
Пример:
```
LPUSH list1 1 2 3
(integer) 3
LPOP list1 0 -1
1)3
2)2
3)1
```
### RPUSH key element [element ...]
Вставляет элементы справа в список по ключу key. Если элементов несколько, они вставляются так, как будто для каждого из них по порядку была бы вызвана эта команда. Если значения по ключу не существовало, список создается.
Пример:
```
RPUSH list1 1 2 3
(integer) 3
LPOP list1 0 -1
1)1
2)2
3)3
```
### RADDTOSET key element [element ...]
Вставляет справа в список по ключу key элементы, которых еще нет в списке. Если элементов несколько, они вставляются так, как будто для каждого из них по порядку была бы вызвана эта команда. Если значения по ключу не существовало, список создается.
Пример:
```
RPUSH list1 1 2 3
(integer) 3
RADDTOSET list1 3 5 8 4 8
LPOP list1 0 -1
1)1
2)2
3)3
4)5
5)8
6)4
```
### LPOP key [count]
Удаляет и возвращает элемент слева списка. Параметр count - количество удаляемых элементов, может быть либо единственным числом - тогда это количество элементов с края, либо двумя числами - тогда это индексы первого и последнего удаляемых элементов. Индексы могут быть отрицательными для доступа с конца списка. Если количество удаляемых элементов превышает количество элементов в списке, возвращается доступное количество.
Пример:
```
RPUSH list1 1 2 3 4 5 6 7 8 9 10
(integer) 10
LPOP list1 2
1)1
2)2

LPOP list1 2 -2
1)5
2)6
3)7
4)8
5)9

LPOP list1
3
```
### RPOP key [count]
Удаляет и возвращает элемент слева списка. Параметр count - количество удаляемых элементов, может быть либо единственным числом - тогда это количество элементов с края, либо двумя числами - тогда это индексы первого и последнего удаляемых элементов. Индексы могут быть отрицательными для доступа с конца списка. Если количество удаляемых элементо превышает количество элементов в списке, возвращается доступное количество.
Пример:
```
RPUSH list1 1 2 3 4 5 6 7 8 9 10
(integer) 10
RPOP list1 2
1)10
2)9

RPOP list1 2 -2
1)7
2)6
3)5
4)4
5)3

RPOP list1
1
```
### LSET key index element
Устанавливает значение элемента с индексом index списка по ключу key равным element. Если элемента с этим индексом не существует, возвращается ошибка.
Пример:
```
RPUSH list1 0 1 2 3 4 5 6 7 8 9
(integer) 10
LSET list1 3 30
OK
LGET list1 3
30
LSET list1 20 2
Index out of range
```
### LGET key index
Получает значение элемента с индексом index из списка по ключу key. Если элемента с этим индексом не существует, возвращается ошибка.
Пример:
```
RPUSH list1 0 1 2 3 4 5 6 7 8 9
(integer) 10
LSET list1 3 30
OK
LGET list1 3
30
LSET list1 20 2
Index out of range
```

## 2. Добавить возможность сохранения и чтения с диска
Добавить возможность сохранения и чтения состояния нашей базы данных на диск/с диска. Сохранение на диск должно происходить перед выходом из main, чтение должно происходить перед началом работы, в начале main. Сами команды по работе с базой идут в блоке между загрузкой предыдущего состояния и сохранением текущего. Для сохранения и чтения с диска рекомендуется использовать json-encoded файл.

```
main(){
    // read from disk if exists

    // do operations

    // save to disk
}

```

# Homework 4 

Для понимания всех терминов смотрите в requirements.md в папке project_requirements.

Глобально пока мы работаем только со статускодами 200 (http.StatusOK), 404 (http.StatusNotFound) и 400 (http.StatusBadRequest)

Детальнее прочитать про значение статусов можно [тут](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).

Для передачи и получения значения используйте json следующего вида (прочитайте, про [struct tags](https://www.digitalocean.com/community/tutorials/how-to-use-struct-tags-in-go), чтобы сделать value с маленькой буквы)

```json
{"value":"some-value"}
```

## 1. Добавить /health endpoint

Необходимо добавить эндпойнт /health, который возвращает статус 200 (OK) на GET запрос

```
curl -v http://localhost:8090/health
```

```
hexzedels@hexzedels:~/Work/Teaching/BolshoiGolang$ curl -v http://localhost:8090/health
*   Trying ::1:8090...
* TCP_NODELAY set
* Connected to localhost (::1) port 8090 (#0)
> GET /health HTTP/1.1
> Host: localhost:8090
> User-Agent: curl/7.68.0
> Accept: */*
> 
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< Date: Tue, 15 Oct 2024 21:40:21 GMT
< Content-Length: 0
< 
* Connection #0 to host localhost left intact
```

## 2. Добавить GET /scalar/get/:key endpoint

Необходимо добавить эндпойнт /scalar/get/:key, который возвращает json, содержащий скаляр, соответствующий ключу key

Request:

```
curl --request GET
  --url http://localhost:8090/scalar/get/123
```

Response (200 или 400 статус):

```
{"Value":"456"}
```

## 3. Добавить PUT /scalar/set/:key + json body endpoint

Необходимо добавить эндпойнт /scalar/set/:key, в который можно послать json в body, содержащий скаляр, который нужно поставить для ключа key

Request:

```
curl --request PUT \
  --url http://localhost:8090/scalar/set/123 \
  --header 'Content-Type: application/json' \
  --data '{
	"Value":"456"
}'
```

Response:

200 или 404 статус